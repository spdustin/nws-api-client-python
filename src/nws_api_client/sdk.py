"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from .httpclient import AsyncHttpClient, ClientOwner, HttpClient, close_clients
from .sdkconfiguration import SDKConfiguration
from .utils.logger import Logger, get_default_logger
from .utils.retries import RetryConfig
from datetime import date, datetime
from enum import Enum
import httpx
from nws_api_client import errors, models, utils
from nws_api_client._hooks import HookContext, SDKHooks
from nws_api_client.types import OptionalNullable, UNSET
from nws_api_client.utils import get_security_from_env
from typing import Any, Callable, Dict, List, Mapping, Optional, Union, cast
import weakref


class AlertsQueryAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_ATOM_PLUS_XML = "application/atom+xml"


class AlertsActiveAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_ATOM_PLUS_XML = "application/atom+xml"


class AlertsActiveCountAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class AlertsActiveZoneAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_ATOM_PLUS_XML = "application/atom+xml"


class AlertsActiveAreaAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_ATOM_PLUS_XML = "application/atom+xml"


class AlertsActiveRegionAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_ATOM_PLUS_XML = "application/atom+xml"


class AlertsTypesAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class AlertsSingleAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_CAP_PLUS_XML = "application/cap+xml"


class CwsuAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class CwasAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class CwaAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_VND_NOAA_USWX_PLUS_XML = "application/vnd.noaa.uswx+xml"


class SigmetQueryAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class SigmetsByATSUAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class SigmetsByATSUByDateAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class SigmetAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_VND_NOAA_USWX_PLUS_XML = "application/vnd.noaa.uswx+xml"


class GlossaryAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class GridpointAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class GridpointForecastAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_VND_NOAA_DWML_PLUS_XML = "application/vnd.noaa.dwml+xml"


class GridpointForecastHourlyAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_VND_NOAA_DWML_PLUS_XML = "application/vnd.noaa.dwml+xml"


class GridpointStationsAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class StationObservationListAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class StationObservationLatestAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_VND_NOAA_OBS_PLUS_XML = "application/vnd.noaa.obs+xml"
    APPLICATION_VND_NOAA_USWX_PLUS_XML = "application/vnd.noaa.uswx+xml"


class StationObservationTimeAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_VND_NOAA_OBS_PLUS_XML = "application/vnd.noaa.obs+xml"
    APPLICATION_VND_NOAA_USWX_PLUS_XML = "application/vnd.noaa.uswx+xml"


class TafsAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class TafAcceptEnum(str, Enum):
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"
    APPLICATION_VND_WMO_IWXXM_PLUS_XML = "application/vnd.wmo.iwxxm+xml"


class ObsStationsAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ObsStationAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class OfficeHeadlineAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class OfficeHeadlinesAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class PointAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class RadarServersAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class RadarServerAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class RadarStationsAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class RadarStationAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class RadarStationAlarmsAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class RadarQueueAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class RadarProfilerAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ProductsQueryAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ProductLocationsAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ProductTypesAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ProductAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ProductsTypeAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ProductsTypeLocationsAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class LocationProductsAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ProductsTypeLocationAcceptEnum(str, Enum):
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ZoneListAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ZoneListTypeAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ZoneAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ZoneForecastAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ZoneObsAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class ZoneStationsAcceptEnum(str, Enum):
    APPLICATION_GEO_PLUS_JSON = "application/geo+json"
    APPLICATION_LD_PLUS_JSON = "application/ld+json"
    APPLICATION_PROBLEM_PLUS_JSON = "application/problem+json"


class NwsClient(BaseSDK):
    r"""weather.gov API: weather.gov API
    https://www.weather.gov/documentation/services-web-api - Full API documentation
    """

    def __init__(
        self,
        user_agent: Optional[Union[Optional[str], Callable[[], Optional[str]]]] = None,
        server_idx: Optional[int] = None,
        server_url: Optional[str] = None,
        url_params: Optional[Dict[str, str]] = None,
        client: Optional[HttpClient] = None,
        async_client: Optional[AsyncHttpClient] = None,
        retry_config: OptionalNullable[RetryConfig] = UNSET,
        timeout_ms: Optional[int] = None,
        debug_logger: Optional[Logger] = None,
    ) -> None:
        r"""Instantiates the SDK configuring it with the provided parameters.

        :param user_agent: The user_agent required for authentication
        :param server_idx: The index of the server to use for all methods
        :param server_url: The server URL to use for all methods
        :param url_params: Parameters to optionally template the server URL with
        :param client: The HTTP client to use for all synchronous methods
        :param async_client: The Async HTTP client to use for all asynchronous methods
        :param retry_config: The retry configuration to use for all supported methods
        :param timeout_ms: Optional request timeout applied to each operation in milliseconds
        """
        client_supplied = True
        if client is None:
            client = httpx.Client()
            client_supplied = False

        assert issubclass(
            type(client), HttpClient
        ), "The provided client must implement the HttpClient protocol."

        async_client_supplied = True
        if async_client is None:
            async_client = httpx.AsyncClient()
            async_client_supplied = False

        if debug_logger is None:
            debug_logger = get_default_logger()

        assert issubclass(
            type(async_client), AsyncHttpClient
        ), "The provided async_client must implement the AsyncHttpClient protocol."

        security: Any = None
        if callable(user_agent):
            # pylint: disable=unnecessary-lambda-assignment
            security = lambda: models.Security(user_agent=user_agent())
        else:
            security = models.Security(user_agent=user_agent)

        if server_url is not None:
            if url_params is not None:
                server_url = utils.template_url(server_url, url_params)

        BaseSDK.__init__(
            self,
            SDKConfiguration(
                client=client,
                client_supplied=client_supplied,
                async_client=async_client,
                async_client_supplied=async_client_supplied,
                security=security,
                server_url=server_url,
                server_idx=server_idx,
                retry_config=retry_config,
                timeout_ms=timeout_ms,
                debug_logger=debug_logger,
            ),
        )

        hooks = SDKHooks()

        current_server_url, *_ = self.sdk_configuration.get_server_details()
        server_url, self.sdk_configuration.client = hooks.sdk_init(
            current_server_url, client
        )
        if current_server_url != server_url:
            self.sdk_configuration.server_url = server_url

        # pylint: disable=protected-access
        self.sdk_configuration.__dict__["_hooks"] = hooks

        weakref.finalize(
            self,
            close_clients,
            cast(ClientOwner, self.sdk_configuration),
            self.sdk_configuration.client,
            self.sdk_configuration.client_supplied,
            self.sdk_configuration.async_client,
            self.sdk_configuration.async_client_supplied,
        )

    def __enter__(self):
        return self

    async def __aenter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if (
            self.sdk_configuration.client is not None
            and not self.sdk_configuration.client_supplied
        ):
            self.sdk_configuration.client.close()
        self.sdk_configuration.client = None

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if (
            self.sdk_configuration.async_client is not None
            and not self.sdk_configuration.async_client_supplied
        ):
            await self.sdk_configuration.async_client.aclose()
        self.sdk_configuration.async_client = None

    def alerts_query(
        self,
        *,
        active: Optional[bool] = None,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        status: Optional[List[models.AlertStatusParameter]] = None,
        message_type: Optional[List[models.AlertMessageTypeParameter]] = None,
        event: Optional[List[str]] = None,
        code: Optional[List[str]] = None,
        area: Optional[List[models.AreaCode]] = None,
        point: Optional[str] = None,
        region: Optional[List[models.MarineRegionCode]] = None,
        region_type: Optional[models.AlertRegionType] = None,
        zone: Optional[List[str]] = None,
        urgency: Optional[List[models.AlertUrgency]] = None,
        severity: Optional[List[models.AlertSeverity]] = None,
        certainty: Optional[List[models.AlertCertainty]] = None,
        limit: Optional[int] = 500,
        cursor: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsQueryAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsQueryResponse:
        r"""Returns all alerts

        :param active: List only active alerts (use /alerts/active endpoints instead)
        :param start: Start time
        :param end: End time
        :param status: Status (actual, exercise, system, test, draft)
        :param message_type: Message type (alert, update, cancel)
        :param event: Event name
        :param code: Event code
        :param area: State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
        :param point: Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone
        :param region: Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
        :param region_type: Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone
        :param zone: Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type
        :param urgency: Urgency (immediate, expected, future, past, unknown)
        :param severity: Severity (extreme, severe, moderate, minor, unknown)
        :param certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :param limit: Limit
        :param cursor: Pagination cursor
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AlertsQueryRequest(
            active=active,
            start=start,
            end=end,
            status=status,
            message_type=message_type,
            event=event,
            code=code,
            area=area,
            point=point,
            region=region,
            region_type=region_type,
            zone=zone,
            urgency=urgency,
            severity=severity,
            certainty=certainty,
            limit=limit,
            cursor=cursor,
        )

        req = self._build_request(
            method="GET",
            path="/alerts",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/atom+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_query",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.AlertsQueryResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsQueryResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/atom+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.AlertsQueryResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsQueryResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def alerts_query_async(
        self,
        *,
        active: Optional[bool] = None,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        status: Optional[List[models.AlertStatusParameter]] = None,
        message_type: Optional[List[models.AlertMessageTypeParameter]] = None,
        event: Optional[List[str]] = None,
        code: Optional[List[str]] = None,
        area: Optional[List[models.AreaCode]] = None,
        point: Optional[str] = None,
        region: Optional[List[models.MarineRegionCode]] = None,
        region_type: Optional[models.AlertRegionType] = None,
        zone: Optional[List[str]] = None,
        urgency: Optional[List[models.AlertUrgency]] = None,
        severity: Optional[List[models.AlertSeverity]] = None,
        certainty: Optional[List[models.AlertCertainty]] = None,
        limit: Optional[int] = 500,
        cursor: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsQueryAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsQueryResponse:
        r"""Returns all alerts

        :param active: List only active alerts (use /alerts/active endpoints instead)
        :param start: Start time
        :param end: End time
        :param status: Status (actual, exercise, system, test, draft)
        :param message_type: Message type (alert, update, cancel)
        :param event: Event name
        :param code: Event code
        :param area: State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
        :param point: Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone
        :param region: Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
        :param region_type: Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone
        :param zone: Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type
        :param urgency: Urgency (immediate, expected, future, past, unknown)
        :param severity: Severity (extreme, severe, moderate, minor, unknown)
        :param certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :param limit: Limit
        :param cursor: Pagination cursor
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AlertsQueryRequest(
            active=active,
            start=start,
            end=end,
            status=status,
            message_type=message_type,
            event=event,
            code=code,
            area=area,
            point=point,
            region=region,
            region_type=region_type,
            zone=zone,
            urgency=urgency,
            severity=severity,
            certainty=certainty,
            limit=limit,
            cursor=cursor,
        )

        req = self._build_request_async(
            method="GET",
            path="/alerts",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/atom+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_query",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.AlertsQueryResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsQueryResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/atom+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.AlertsQueryResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsQueryResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def alerts_active(
        self,
        *,
        status: Optional[List[models.AlertStatusParameter]] = None,
        message_type: Optional[List[models.AlertMessageTypeParameter]] = None,
        event: Optional[List[str]] = None,
        code: Optional[List[str]] = None,
        area: Optional[List[models.AreaCode]] = None,
        point: Optional[str] = None,
        region: Optional[List[models.MarineRegionCode]] = None,
        region_type: Optional[models.AlertRegionType] = None,
        zone: Optional[List[str]] = None,
        urgency: Optional[List[models.AlertUrgency]] = None,
        severity: Optional[List[models.AlertSeverity]] = None,
        certainty: Optional[List[models.AlertCertainty]] = None,
        limit: Optional[int] = 500,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsActiveAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsActiveResponse:
        r"""Returns all currently active alerts

        :param status: Status (actual, exercise, system, test, draft)
        :param message_type: Message type (alert, update, cancel)
        :param event: Event name
        :param code: Event code
        :param area: State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
        :param point: Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone
        :param region: Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
        :param region_type: Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone
        :param zone: Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type
        :param urgency: Urgency (immediate, expected, future, past, unknown)
        :param severity: Severity (extreme, severe, moderate, minor, unknown)
        :param certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :param limit: Limit
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AlertsActiveRequest(
            status=status,
            message_type=message_type,
            event=event,
            code=code,
            area=area,
            point=point,
            region=region,
            region_type=region_type,
            zone=zone,
            urgency=urgency,
            severity=severity,
            certainty=certainty,
            limit=limit,
        )

        req = self._build_request(
            method="GET",
            path="/alerts/active",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/atom+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_active",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.AlertsActiveResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsActiveResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/atom+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.AlertsActiveResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsActiveResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def alerts_active_async(
        self,
        *,
        status: Optional[List[models.AlertStatusParameter]] = None,
        message_type: Optional[List[models.AlertMessageTypeParameter]] = None,
        event: Optional[List[str]] = None,
        code: Optional[List[str]] = None,
        area: Optional[List[models.AreaCode]] = None,
        point: Optional[str] = None,
        region: Optional[List[models.MarineRegionCode]] = None,
        region_type: Optional[models.AlertRegionType] = None,
        zone: Optional[List[str]] = None,
        urgency: Optional[List[models.AlertUrgency]] = None,
        severity: Optional[List[models.AlertSeverity]] = None,
        certainty: Optional[List[models.AlertCertainty]] = None,
        limit: Optional[int] = 500,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsActiveAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsActiveResponse:
        r"""Returns all currently active alerts

        :param status: Status (actual, exercise, system, test, draft)
        :param message_type: Message type (alert, update, cancel)
        :param event: Event name
        :param code: Event code
        :param area: State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
        :param point: Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone
        :param region: Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
        :param region_type: Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone
        :param zone: Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type
        :param urgency: Urgency (immediate, expected, future, past, unknown)
        :param severity: Severity (extreme, severe, moderate, minor, unknown)
        :param certainty: Certainty (observed, likely, possible, unlikely, unknown)
        :param limit: Limit
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AlertsActiveRequest(
            status=status,
            message_type=message_type,
            event=event,
            code=code,
            area=area,
            point=point,
            region=region,
            region_type=region_type,
            zone=zone,
            urgency=urgency,
            severity=severity,
            certainty=certainty,
            limit=limit,
        )

        req = self._build_request_async(
            method="GET",
            path="/alerts/active",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/atom+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_active",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.AlertsActiveResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsActiveResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/atom+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.AlertsActiveResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsActiveResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def alerts_active_count(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsActiveCountAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsActiveCountResponse:
        r"""Returns info on the number of active alerts

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="GET",
            path="/alerts/active/count",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_active_count",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsActiveCountResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertsActiveCountResponseBody
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsActiveCountResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def alerts_active_count_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsActiveCountAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsActiveCountResponse:
        r"""Returns info on the number of active alerts

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="GET",
            path="/alerts/active/count",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_active_count",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsActiveCountResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertsActiveCountResponseBody
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsActiveCountResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def alerts_active_zone(
        self,
        *,
        zone_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsActiveZoneAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsActiveZoneResponse:
        r"""Returns active alerts for the given NWS public zone or county

        :param zone_id: NWS public zone/county identifier
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AlertsActiveZoneRequest(
            zone_id=zone_id,
        )

        req = self._build_request(
            method="GET",
            path="/alerts/active/zone/{zoneId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/atom+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_active_zone",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.AlertsActiveZoneResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsActiveZoneResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/atom+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.AlertsActiveZoneResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsActiveZoneResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def alerts_active_zone_async(
        self,
        *,
        zone_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsActiveZoneAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsActiveZoneResponse:
        r"""Returns active alerts for the given NWS public zone or county

        :param zone_id: NWS public zone/county identifier
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AlertsActiveZoneRequest(
            zone_id=zone_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/alerts/active/zone/{zoneId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/atom+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_active_zone",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.AlertsActiveZoneResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsActiveZoneResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/atom+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.AlertsActiveZoneResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsActiveZoneResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def alerts_active_area(
        self,
        *,
        area: models.Area,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsActiveAreaAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsActiveAreaResponse:
        r"""Returns active alerts for the given area (state or marine area)

        :param area: State or marine area code
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AlertsActiveAreaRequest(
            area=area,
        )

        req = self._build_request(
            method="GET",
            path="/alerts/active/area/{area}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/atom+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_active_area",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.AlertsActiveAreaResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsActiveAreaResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/atom+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.AlertsActiveAreaResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsActiveAreaResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def alerts_active_area_async(
        self,
        *,
        area: models.Area,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsActiveAreaAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsActiveAreaResponse:
        r"""Returns active alerts for the given area (state or marine area)

        :param area: State or marine area code
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AlertsActiveAreaRequest(
            area=area,
        )

        req = self._build_request_async(
            method="GET",
            path="/alerts/active/area/{area}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/atom+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_active_area",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.AlertsActiveAreaResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsActiveAreaResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/atom+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.AlertsActiveAreaResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsActiveAreaResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def alerts_active_region(
        self,
        *,
        region: models.MarineRegionCode,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsActiveRegionAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsActiveRegionResponse:
        r"""Returns active alerts for the given marine region

        :param region: Marine region ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AlertsActiveRegionRequest(
            region=region,
        )

        req = self._build_request(
            method="GET",
            path="/alerts/active/region/{region}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/atom+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_active_region",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.AlertsActiveRegionResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsActiveRegionResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/atom+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.AlertsActiveRegionResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsActiveRegionResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def alerts_active_region_async(
        self,
        *,
        region: models.MarineRegionCode,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsActiveRegionAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsActiveRegionResponse:
        r"""Returns active alerts for the given marine region

        :param region: Marine region ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AlertsActiveRegionRequest(
            region=region,
        )

        req = self._build_request_async(
            method="GET",
            path="/alerts/active/region/{region}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/atom+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_active_region",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.AlertsActiveRegionResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsActiveRegionResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/atom+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.AlertsActiveRegionResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsActiveRegionResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def alerts_types(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsTypesAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsTypesResponse:
        r"""Returns a list of alert types

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="GET",
            path="/alerts/types",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_types",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsTypesResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertsTypesResponseBody
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsTypesResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def alerts_types_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsTypesAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsTypesResponse:
        r"""Returns a list of alert types

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="GET",
            path="/alerts/types",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_types",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsTypesResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.AlertsTypesResponseBody
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsTypesResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def alerts_single(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsSingleAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsSingleResponse:
        r"""Returns a specific alert

        :param id: Alert identifier
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AlertsSingleRequest(
            id=id,
        )

        req = self._build_request(
            method="GET",
            path="/alerts/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/cap+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_single",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.AlertsSingleResponse(
                result=utils.unmarshal_json(http_res.text, models.AlertGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsSingleResponse(
                result=utils.unmarshal_json(http_res.text, models.AlertJSONLd),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/cap+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.AlertsSingleResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsSingleResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def alerts_single_async(
        self,
        *,
        id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[AlertsSingleAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.AlertsSingleResponse:
        r"""Returns a specific alert

        :param id: Alert identifier
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.AlertsSingleRequest(
            id=id,
        )

        req = self._build_request_async(
            method="GET",
            path="/alerts/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/cap+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="alerts_single",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.AlertsSingleResponse(
                result=utils.unmarshal_json(http_res.text, models.AlertGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.AlertsSingleResponse(
                result=utils.unmarshal_json(http_res.text, models.AlertJSONLd),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/cap+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.AlertsSingleResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.AlertsSingleResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def cwsu(
        self,
        *,
        cwsu_id: models.NWSCenterWeatherServiceUnitID,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[CwsuAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CwsuResponse:
        r"""Returns metadata about a Center Weather Service Unit

        :param cwsu_id: NWS CWSU ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CwsuRequest(
            cwsu_id=cwsu_id,
        )

        req = self._build_request(
            method="GET",
            path="/aviation/cwsus/{cwsuId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="cwsu",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.CwsuResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.CenterWeatherServiceUnitJSONLd
                ),
                headers={},
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.CwsuResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def cwsu_async(
        self,
        *,
        cwsu_id: models.NWSCenterWeatherServiceUnitID,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[CwsuAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CwsuResponse:
        r"""Returns metadata about a Center Weather Service Unit

        :param cwsu_id: NWS CWSU ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CwsuRequest(
            cwsu_id=cwsu_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/aviation/cwsus/{cwsuId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="cwsu",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.CwsuResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.CenterWeatherServiceUnitJSONLd
                ),
                headers={},
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.CwsuResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def cwas(
        self,
        *,
        cwsu_id: models.NWSCenterWeatherServiceUnitID,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[CwasAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CwasResponse:
        r"""Returns a list of Center Weather Advisories from a CWSU

        :param cwsu_id: NWS CWSU ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CwasRequest(
            cwsu_id=cwsu_id,
        )

        req = self._build_request(
            method="GET",
            path="/aviation/cwsus/{cwsuId}/cwas",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="cwas",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.CwasResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.CenterWeatherAdvisoryCollectionGeoJSON
                ),
                headers={},
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.CwasResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def cwas_async(
        self,
        *,
        cwsu_id: models.NWSCenterWeatherServiceUnitID,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[CwasAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CwasResponse:
        r"""Returns a list of Center Weather Advisories from a CWSU

        :param cwsu_id: NWS CWSU ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CwasRequest(
            cwsu_id=cwsu_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/aviation/cwsus/{cwsuId}/cwas",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="cwas",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.CwasResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.CenterWeatherAdvisoryCollectionGeoJSON
                ),
                headers={},
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.CwasResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def cwa(
        self,
        *,
        cwsu_id: models.NWSCenterWeatherServiceUnitID,
        date_: date,
        sequence: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[CwaAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CwaResponse:
        r"""Returns a list of Center Weather Advisories from a CWSU

        :param cwsu_id: NWS CWSU ID
        :param date_: Date (YYYY-MM-DD format)
        :param sequence: Sequence number
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CwaRequest(
            cwsu_id=cwsu_id,
            date_=date_,
            sequence=sequence,
        )

        req = self._build_request(
            method="GET",
            path="/aviation/cwsus/{cwsuId}/cwas/{date}/{sequence}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/problem+json;q=0.7, application/vnd.noaa.uswx+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="cwa",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.CwaResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.CenterWeatherAdvisoryGeoJSON
                ),
                headers={},
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.uswx+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.CwaResponse(result=http_res_bytes, headers={})
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.CwaResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def cwa_async(
        self,
        *,
        cwsu_id: models.NWSCenterWeatherServiceUnitID,
        date_: date,
        sequence: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[CwaAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.CwaResponse:
        r"""Returns a list of Center Weather Advisories from a CWSU

        :param cwsu_id: NWS CWSU ID
        :param date_: Date (YYYY-MM-DD format)
        :param sequence: Sequence number
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.CwaRequest(
            cwsu_id=cwsu_id,
            date_=date_,
            sequence=sequence,
        )

        req = self._build_request_async(
            method="GET",
            path="/aviation/cwsus/{cwsuId}/cwas/{date}/{sequence}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/problem+json;q=0.7, application/vnd.noaa.uswx+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="cwa",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.CwaResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.CenterWeatherAdvisoryGeoJSON
                ),
                headers={},
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.uswx+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.CwaResponse(result=http_res_bytes, headers={})
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.CwaResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def sigmet_query(
        self,
        *,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        date_: Optional[date] = None,
        atsu: Optional[str] = None,
        sequence: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[SigmetQueryAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SigmetQueryResponse:
        r"""Returns a list of SIGMET/AIRMETs

        :param start: Start time
        :param end: End time
        :param date_: Date (YYYY-MM-DD format)
        :param atsu: ATSU identifier
        :param sequence: SIGMET sequence number
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SigmetQueryRequest(
            start=start,
            end=end,
            date_=date_,
            atsu=atsu,
            sequence=sequence,
        )

        req = self._build_request(
            method="GET",
            path="/aviation/sigmets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="sigmetQuery",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.SigmetQueryResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.SigmetCollectionGeoJSON
                ),
                headers={},
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.SigmetQueryResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def sigmet_query_async(
        self,
        *,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        date_: Optional[date] = None,
        atsu: Optional[str] = None,
        sequence: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[SigmetQueryAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SigmetQueryResponse:
        r"""Returns a list of SIGMET/AIRMETs

        :param start: Start time
        :param end: End time
        :param date_: Date (YYYY-MM-DD format)
        :param atsu: ATSU identifier
        :param sequence: SIGMET sequence number
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SigmetQueryRequest(
            start=start,
            end=end,
            date_=date_,
            atsu=atsu,
            sequence=sequence,
        )

        req = self._build_request_async(
            method="GET",
            path="/aviation/sigmets",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="sigmetQuery",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.SigmetQueryResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.SigmetCollectionGeoJSON
                ),
                headers={},
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.SigmetQueryResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def sigmets_by_atsu(
        self,
        *,
        atsu: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[SigmetsByATSUAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SigmetsByATSUResponse:
        r"""Returns a list of SIGMET/AIRMETs for the specified ATSU

        :param atsu: ATSU identifier
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SigmetsByATSURequest(
            atsu=atsu,
        )

        req = self._build_request(
            method="GET",
            path="/aviation/sigmets/{atsu}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="sigmetsByATSU",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.SigmetsByATSUResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.SigmetCollectionGeoJSON
                ),
                headers={},
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.SigmetsByATSUResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def sigmets_by_atsu_async(
        self,
        *,
        atsu: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[SigmetsByATSUAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SigmetsByATSUResponse:
        r"""Returns a list of SIGMET/AIRMETs for the specified ATSU

        :param atsu: ATSU identifier
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SigmetsByATSURequest(
            atsu=atsu,
        )

        req = self._build_request_async(
            method="GET",
            path="/aviation/sigmets/{atsu}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="sigmetsByATSU",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.SigmetsByATSUResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.SigmetCollectionGeoJSON
                ),
                headers={},
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.SigmetsByATSUResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def sigmets_by_atsu_by_date(
        self,
        *,
        atsu: str,
        date_: date,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[SigmetsByATSUByDateAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SigmetsByATSUByDateResponse:
        r"""Returns a list of SIGMET/AIRMETs for the specified ATSU for the specified date

        :param atsu: ATSU identifier
        :param date_: Date (YYYY-MM-DD format)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SigmetsByATSUByDateRequest(
            atsu=atsu,
            date_=date_,
        )

        req = self._build_request(
            method="GET",
            path="/aviation/sigmets/{atsu}/{date}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="sigmetsByATSUByDate",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.SigmetsByATSUByDateResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.SigmetCollectionGeoJSON
                ),
                headers={},
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.SigmetsByATSUByDateResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def sigmets_by_atsu_by_date_async(
        self,
        *,
        atsu: str,
        date_: date,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[SigmetsByATSUByDateAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SigmetsByATSUByDateResponse:
        r"""Returns a list of SIGMET/AIRMETs for the specified ATSU for the specified date

        :param atsu: ATSU identifier
        :param date_: Date (YYYY-MM-DD format)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SigmetsByATSUByDateRequest(
            atsu=atsu,
            date_=date_,
        )

        req = self._build_request_async(
            method="GET",
            path="/aviation/sigmets/{atsu}/{date}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="sigmetsByATSUByDate",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.SigmetsByATSUByDateResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.SigmetCollectionGeoJSON
                ),
                headers={},
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.SigmetsByATSUByDateResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def sigmet(
        self,
        *,
        atsu: str,
        date_: date,
        time: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[SigmetAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SigmetResponse:
        r"""Returns a specific SIGMET/AIRMET

        :param atsu: ATSU identifier
        :param date_: Date (YYYY-MM-DD format)
        :param time: Time (HHMM format). This time is always specified in UTC (Zulu) time.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SigmetRequest(
            atsu=atsu,
            date_=date_,
            time=time,
        )

        req = self._build_request(
            method="GET",
            path="/aviation/sigmets/{atsu}/{date}/{time}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/problem+json;q=0.7, application/vnd.noaa.uswx+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="sigmet",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.SigmetResponse(
                result=utils.unmarshal_json(http_res.text, models.SigmetGeoJSON),
                headers={},
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.uswx+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.SigmetResponse(result=http_res_bytes, headers={})
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.SigmetResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def sigmet_async(
        self,
        *,
        atsu: str,
        date_: date,
        time: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[SigmetAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.SigmetResponse:
        r"""Returns a specific SIGMET/AIRMET

        :param atsu: ATSU identifier
        :param date_: Date (YYYY-MM-DD format)
        :param time: Time (HHMM format). This time is always specified in UTC (Zulu) time.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.SigmetRequest(
            atsu=atsu,
            date_=date_,
            time=time,
        )

        req = self._build_request_async(
            method="GET",
            path="/aviation/sigmets/{atsu}/{date}/{time}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/problem+json;q=0.7, application/vnd.noaa.uswx+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="sigmet",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.SigmetResponse(
                result=utils.unmarshal_json(http_res.text, models.SigmetGeoJSON),
                headers={},
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.uswx+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.SigmetResponse(result=http_res_bytes, headers={})
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.SigmetResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def glossary(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[GlossaryAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GlossaryResponse:
        r"""Returns glossary terms

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="GET",
            path="/glossary",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="glossary",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.GlossaryResponse(
                result=utils.unmarshal_json(http_res.text, models.GlossaryResponseBody),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.GlossaryResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def glossary_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[GlossaryAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GlossaryResponse:
        r"""Returns glossary terms

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="GET",
            path="/glossary",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="glossary",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.GlossaryResponse(
                result=utils.unmarshal_json(http_res.text, models.GlossaryResponseBody),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.GlossaryResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def gridpoint(
        self,
        *,
        wfo: models.NWSForecastOfficeID,
        point: List[int],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[GridpointAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GridpointResponse:
        r"""Returns raw numerical forecast data for a 2.5km grid area

        :param wfo: Forecast office ID
        :param point: Two-element array encoding grid X and Y (comma-separated)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GridpointRequest(
            wfo=wfo,
            point=point,
        )

        req = self._build_request(
            method="GET",
            path="/gridpoints/{wfo}/{point}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="gridpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.GridpointResponse(
                result=utils.unmarshal_json(http_res.text, models.GridpointGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.GridpointResponse(
                result=utils.unmarshal_json(http_res.text, models.Gridpoint),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.GridpointResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def gridpoint_async(
        self,
        *,
        wfo: models.NWSForecastOfficeID,
        point: List[int],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[GridpointAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GridpointResponse:
        r"""Returns raw numerical forecast data for a 2.5km grid area

        :param wfo: Forecast office ID
        :param point: Two-element array encoding grid X and Y (comma-separated)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GridpointRequest(
            wfo=wfo,
            point=point,
        )

        req = self._build_request_async(
            method="GET",
            path="/gridpoints/{wfo}/{point}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="gridpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.GridpointResponse(
                result=utils.unmarshal_json(http_res.text, models.GridpointGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.GridpointResponse(
                result=utils.unmarshal_json(http_res.text, models.Gridpoint),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.GridpointResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def gridpoint_forecast(
        self,
        *,
        wfo: models.NWSForecastOfficeID,
        point: List[int],
        feature_flags: Optional[List[models.GridpointForecastFeatureFlags]] = None,
        units: Optional[
            models.GridpointForecastUnits
        ] = models.GridpointForecastUnits.US,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[GridpointForecastAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GridpointForecastResponse:
        r"""Returns a textual forecast for a 2.5km grid area

        :param wfo: Forecast office ID
        :param point: Two-element array encoding grid X and Y (comma-separated)
        :param feature_flags: Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
        :param units: Use US customary or SI (metric) units in textual output
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GridpointForecastRequest(
            wfo=wfo,
            point=point,
            feature_flags=feature_flags,
            units=units,
        )

        req = self._build_request(
            method="GET",
            path="/gridpoints/{wfo}/{point}/forecast",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/vnd.noaa.dwml+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="gridpoint_forecast",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.GridpointForecastResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.GridpointForecastGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.GridpointForecastResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.GridpointForecastJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.dwml+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.GridpointForecastResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.GridpointForecastResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def gridpoint_forecast_async(
        self,
        *,
        wfo: models.NWSForecastOfficeID,
        point: List[int],
        feature_flags: Optional[List[models.GridpointForecastFeatureFlags]] = None,
        units: Optional[
            models.GridpointForecastUnits
        ] = models.GridpointForecastUnits.US,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[GridpointForecastAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GridpointForecastResponse:
        r"""Returns a textual forecast for a 2.5km grid area

        :param wfo: Forecast office ID
        :param point: Two-element array encoding grid X and Y (comma-separated)
        :param feature_flags: Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
        :param units: Use US customary or SI (metric) units in textual output
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GridpointForecastRequest(
            wfo=wfo,
            point=point,
            feature_flags=feature_flags,
            units=units,
        )

        req = self._build_request_async(
            method="GET",
            path="/gridpoints/{wfo}/{point}/forecast",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/vnd.noaa.dwml+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="gridpoint_forecast",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.GridpointForecastResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.GridpointForecastGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.GridpointForecastResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.GridpointForecastJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.dwml+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.GridpointForecastResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.GridpointForecastResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def gridpoint_forecast_hourly(
        self,
        *,
        wfo: models.NWSForecastOfficeID,
        point: List[int],
        feature_flags: Optional[List[models.GridpointForecastFeatureFlags]] = None,
        units: Optional[
            models.GridpointForecastUnits
        ] = models.GridpointForecastUnits.US,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[GridpointForecastHourlyAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GridpointForecastHourlyResponse:
        r"""Returns a textual hourly forecast for a 2.5km grid area

        :param wfo: Forecast office ID
        :param point: Two-element array encoding grid X and Y (comma-separated)
        :param feature_flags: Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
        :param units: Use US customary or SI (metric) units in textual output
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GridpointForecastHourlyRequest(
            wfo=wfo,
            point=point,
            feature_flags=feature_flags,
            units=units,
        )

        req = self._build_request(
            method="GET",
            path="/gridpoints/{wfo}/{point}/forecast/hourly",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/vnd.noaa.dwml+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="gridpoint_forecast_hourly",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.GridpointForecastHourlyResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.GridpointForecastGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.GridpointForecastHourlyResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.GridpointForecastJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.dwml+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.GridpointForecastHourlyResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.GridpointForecastHourlyResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def gridpoint_forecast_hourly_async(
        self,
        *,
        wfo: models.NWSForecastOfficeID,
        point: List[int],
        feature_flags: Optional[List[models.GridpointForecastFeatureFlags]] = None,
        units: Optional[
            models.GridpointForecastUnits
        ] = models.GridpointForecastUnits.US,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[GridpointForecastHourlyAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GridpointForecastHourlyResponse:
        r"""Returns a textual hourly forecast for a 2.5km grid area

        :param wfo: Forecast office ID
        :param point: Two-element array encoding grid X and Y (comma-separated)
        :param feature_flags: Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
        :param units: Use US customary or SI (metric) units in textual output
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GridpointForecastHourlyRequest(
            wfo=wfo,
            point=point,
            feature_flags=feature_flags,
            units=units,
        )

        req = self._build_request_async(
            method="GET",
            path="/gridpoints/{wfo}/{point}/forecast/hourly",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.5, application/vnd.noaa.dwml+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="gridpoint_forecast_hourly",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.GridpointForecastHourlyResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.GridpointForecastGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.GridpointForecastHourlyResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.GridpointForecastJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.dwml+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.GridpointForecastHourlyResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.GridpointForecastHourlyResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def gridpoint_stations(
        self,
        *,
        wfo: models.NWSForecastOfficeID,
        point: List[int],
        limit: Optional[int] = 500,
        cursor: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[GridpointStationsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GridpointStationsResponse:
        r"""Returns a list of observation stations usable for a given 2.5km grid area

        :param wfo: Forecast office ID
        :param point: Two-element array encoding grid X and Y (comma-separated)
        :param limit: Limit
        :param cursor: Pagination cursor
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GridpointStationsRequest(
            wfo=wfo,
            point=point,
            limit=limit,
            cursor=cursor,
        )

        req = self._build_request(
            method="GET",
            path="/gridpoints/{wfo}/{point}/stations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="gridpoint_stations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.GridpointStationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.GridpointStationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.GridpointStationsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def gridpoint_stations_async(
        self,
        *,
        wfo: models.NWSForecastOfficeID,
        point: List[int],
        limit: Optional[int] = 500,
        cursor: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[GridpointStationsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.GridpointStationsResponse:
        r"""Returns a list of observation stations usable for a given 2.5km grid area

        :param wfo: Forecast office ID
        :param point: Two-element array encoding grid X and Y (comma-separated)
        :param limit: Limit
        :param cursor: Pagination cursor
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.GridpointStationsRequest(
            wfo=wfo,
            point=point,
            limit=limit,
            cursor=cursor,
        )

        req = self._build_request_async(
            method="GET",
            path="/gridpoints/{wfo}/{point}/stations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="gridpoint_stations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.GridpointStationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.GridpointStationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.GridpointStationsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def station_observation_list(
        self,
        *,
        station_id: str,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        limit: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[StationObservationListAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.StationObservationListResponse:
        r"""Returns a list of observations for a given station

        :param station_id: Observation station ID
        :param start: Start time
        :param end: End time
        :param limit: Limit
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StationObservationListRequest(
            station_id=station_id,
            start=start,
            end=end,
            limit=limit,
        )

        req = self._build_request(
            method="GET",
            path="/stations/{stationId}/observations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="station_observation_list",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.StationObservationListResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.StationObservationListResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.StationObservationListResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def station_observation_list_async(
        self,
        *,
        station_id: str,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        limit: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[StationObservationListAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.StationObservationListResponse:
        r"""Returns a list of observations for a given station

        :param station_id: Observation station ID
        :param start: Start time
        :param end: End time
        :param limit: Limit
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StationObservationListRequest(
            station_id=station_id,
            start=start,
            end=end,
            limit=limit,
        )

        req = self._build_request_async(
            method="GET",
            path="/stations/{stationId}/observations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="station_observation_list",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.StationObservationListResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.StationObservationListResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.StationObservationListResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def station_observation_latest(
        self,
        *,
        station_id: str,
        require_qc: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[StationObservationLatestAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.StationObservationLatestResponse:
        r"""Returns the latest observation for a station

        :param station_id: Observation station ID
        :param require_qc: Require QC
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StationObservationLatestRequest(
            station_id=station_id,
            require_qc=require_qc,
        )

        req = self._build_request(
            method="GET",
            path="/stations/{stationId}/observations/latest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.6, application/vnd.noaa.obs+xml;q=0.4, application/vnd.noaa.uswx+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="station_observation_latest",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.StationObservationLatestResponse(
                result=utils.unmarshal_json(http_res.text, models.ObservationGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.StationObservationLatestResponse(
                result=utils.unmarshal_json(http_res.text, models.Observation),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.obs+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.StationObservationLatestResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.uswx+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.StationObservationLatestResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.StationObservationLatestResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def station_observation_latest_async(
        self,
        *,
        station_id: str,
        require_qc: Optional[bool] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[StationObservationLatestAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.StationObservationLatestResponse:
        r"""Returns the latest observation for a station

        :param station_id: Observation station ID
        :param require_qc: Require QC
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StationObservationLatestRequest(
            station_id=station_id,
            require_qc=require_qc,
        )

        req = self._build_request_async(
            method="GET",
            path="/stations/{stationId}/observations/latest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.6, application/vnd.noaa.obs+xml;q=0.4, application/vnd.noaa.uswx+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="station_observation_latest",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.StationObservationLatestResponse(
                result=utils.unmarshal_json(http_res.text, models.ObservationGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.StationObservationLatestResponse(
                result=utils.unmarshal_json(http_res.text, models.Observation),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.obs+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.StationObservationLatestResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.uswx+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.StationObservationLatestResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.StationObservationLatestResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def station_observation_time(
        self,
        *,
        station_id: str,
        time: datetime,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[StationObservationTimeAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.StationObservationTimeResponse:
        r"""Returns a single observation.

        :param station_id: Observation station ID
        :param time: Timestamp of requested observation
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StationObservationTimeRequest(
            station_id=station_id,
            time=time,
        )

        req = self._build_request(
            method="GET",
            path="/stations/{stationId}/observations/{time}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.6, application/vnd.noaa.obs+xml;q=0.4, application/vnd.noaa.uswx+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="station_observation_time",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.StationObservationTimeResponse(
                result=utils.unmarshal_json(http_res.text, models.ObservationGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.StationObservationTimeResponse(
                result=utils.unmarshal_json(http_res.text, models.Observation),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.obs+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.StationObservationTimeResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.uswx+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.StationObservationTimeResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.StationObservationTimeResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def station_observation_time_async(
        self,
        *,
        station_id: str,
        time: datetime,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[StationObservationTimeAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.StationObservationTimeResponse:
        r"""Returns a single observation.

        :param station_id: Observation station ID
        :param time: Timestamp of requested observation
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.StationObservationTimeRequest(
            station_id=station_id,
            time=time,
        )

        req = self._build_request_async(
            method="GET",
            path="/stations/{stationId}/observations/{time}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.8, application/problem+json;q=0.6, application/vnd.noaa.obs+xml;q=0.4, application/vnd.noaa.uswx+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="station_observation_time",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.StationObservationTimeResponse(
                result=utils.unmarshal_json(http_res.text, models.ObservationGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.StationObservationTimeResponse(
                result=utils.unmarshal_json(http_res.text, models.Observation),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.obs+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.StationObservationTimeResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/vnd.noaa.uswx+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.StationObservationTimeResponse(
                result=http_res_bytes,
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.StationObservationTimeResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def tafs(
        self,
        *,
        station_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[TafsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TafsResponse:
        r"""Returns Terminal Aerodrome Forecasts for the specified airport station.

        :param station_id: Observation station ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TafsRequest(
            station_id=station_id,
        )

        req = self._build_request(
            method="GET",
            path="/stations/{stationId}/tafs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="tafs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.TafsResponse(
                result=utils.unmarshal_json(http_res.text, Any), headers={}
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.TafsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def tafs_async(
        self,
        *,
        station_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[TafsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TafsResponse:
        r"""Returns Terminal Aerodrome Forecasts for the specified airport station.

        :param station_id: Observation station ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TafsRequest(
            station_id=station_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/stations/{stationId}/tafs",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="tafs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.TafsResponse(
                result=utils.unmarshal_json(http_res.text, Any), headers={}
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.TafsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def taf(
        self,
        *,
        station_id: str,
        date_: date,
        time: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[TafAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TafResponse:
        r"""Returns a single Terminal Aerodrome Forecast.

        :param station_id: Observation station ID
        :param date_: Date (YYYY-MM-DD format)
        :param time: Time (HHMM format). This time is always specified in UTC (Zulu) time.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TafRequest(
            station_id=station_id,
            date_=date_,
            time=time,
        )

        req = self._build_request(
            method="GET",
            path="/stations/{stationId}/tafs/{date}/{time}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/problem+json;q=1, application/vnd.wmo.iwxxm+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="taf",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/vnd.wmo.iwxxm+xml"):
            http_res_bytes = utils.stream_to_bytes(http_res)
            return models.TafResponse(result=http_res_bytes, headers={})
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.TafResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def taf_async(
        self,
        *,
        station_id: str,
        date_: date,
        time: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[TafAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.TafResponse:
        r"""Returns a single Terminal Aerodrome Forecast.

        :param station_id: Observation station ID
        :param date_: Date (YYYY-MM-DD format)
        :param time: Time (HHMM format). This time is always specified in UTC (Zulu) time.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.TafRequest(
            station_id=station_id,
            date_=date_,
            time=time,
        )

        req = self._build_request_async(
            method="GET",
            path="/stations/{stationId}/tafs/{date}/{time}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/problem+json;q=1, application/vnd.wmo.iwxxm+xml;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="taf",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/vnd.wmo.iwxxm+xml"):
            http_res_bytes = await utils.stream_to_bytes_async(http_res)
            return models.TafResponse(result=http_res_bytes, headers={})
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.TafResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def obs_stations(
        self,
        *,
        id: Optional[List[str]] = None,
        state: Optional[List[models.AreaCode]] = None,
        limit: Optional[int] = 500,
        cursor: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ObsStationsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ObsStationsResponse:
        r"""Returns a list of observation stations.

        :param id: Filter by observation station ID
        :param state: Filter by state/marine area code
        :param limit: Limit
        :param cursor: Pagination cursor
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ObsStationsRequest(
            id=id,
            state=state,
            limit=limit,
            cursor=cursor,
        )

        req = self._build_request(
            method="GET",
            path="/stations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="obs_stations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ObsStationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ObsStationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ObsStationsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def obs_stations_async(
        self,
        *,
        id: Optional[List[str]] = None,
        state: Optional[List[models.AreaCode]] = None,
        limit: Optional[int] = 500,
        cursor: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ObsStationsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ObsStationsResponse:
        r"""Returns a list of observation stations.

        :param id: Filter by observation station ID
        :param state: Filter by state/marine area code
        :param limit: Limit
        :param cursor: Pagination cursor
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ObsStationsRequest(
            id=id,
            state=state,
            limit=limit,
            cursor=cursor,
        )

        req = self._build_request_async(
            method="GET",
            path="/stations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="obs_stations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ObsStationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ObsStationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ObsStationsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def obs_station(
        self,
        *,
        station_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ObsStationAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ObsStationResponse:
        r"""Returns metadata about a given observation station

        :param station_id: Observation station ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ObsStationRequest(
            station_id=station_id,
        )

        req = self._build_request(
            method="GET",
            path="/stations/{stationId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="obs_station",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ObsStationResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ObsStationResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ObsStationResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def obs_station_async(
        self,
        *,
        station_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ObsStationAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ObsStationResponse:
        r"""Returns metadata about a given observation station

        :param station_id: Observation station ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ObsStationRequest(
            station_id=station_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/stations/{stationId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="obs_station",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ObsStationResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ObsStationResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ObsStationResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def office(
        self,
        *,
        office_id: models.NWSOfficeID,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.OfficeResponse:
        r"""Returns metadata about a NWS forecast office

        :param office_id: NWS office ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.OfficeRequest(
            office_id=office_id,
        )

        req = self._build_request(
            method="GET",
            path="/offices/{officeId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/problem+json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="office",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/problem+json"):
            return models.OfficeResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.OfficeResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def office_async(
        self,
        *,
        office_id: models.NWSOfficeID,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.OfficeResponse:
        r"""Returns metadata about a NWS forecast office

        :param office_id: NWS office ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.OfficeRequest(
            office_id=office_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/offices/{officeId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/problem+json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="office",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/problem+json"):
            return models.OfficeResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.OfficeResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def office_headline(
        self,
        *,
        office_id: models.NWSOfficeID,
        headline_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[OfficeHeadlineAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.OfficeHeadlineResponse:
        r"""Returns a specific news headline for a given NWS office

        :param office_id: NWS office ID
        :param headline_id: Headline record ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.OfficeHeadlineRequest(
            office_id=office_id,
            headline_id=headline_id,
        )

        req = self._build_request(
            method="GET",
            path="/offices/{officeId}/headlines/{headlineId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="office_headline",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.OfficeHeadlineResponse(
                result=utils.unmarshal_json(http_res.text, models.OfficeHeadline),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.OfficeHeadlineResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def office_headline_async(
        self,
        *,
        office_id: models.NWSOfficeID,
        headline_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[OfficeHeadlineAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.OfficeHeadlineResponse:
        r"""Returns a specific news headline for a given NWS office

        :param office_id: NWS office ID
        :param headline_id: Headline record ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.OfficeHeadlineRequest(
            office_id=office_id,
            headline_id=headline_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/offices/{officeId}/headlines/{headlineId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="office_headline",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.OfficeHeadlineResponse(
                result=utils.unmarshal_json(http_res.text, models.OfficeHeadline),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.OfficeHeadlineResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def office_headlines(
        self,
        *,
        office_id: models.NWSOfficeID,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[OfficeHeadlinesAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.OfficeHeadlinesResponse:
        r"""Returns a list of news headlines for a given NWS office

        :param office_id: NWS office ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.OfficeHeadlinesRequest(
            office_id=office_id,
        )

        req = self._build_request(
            method="GET",
            path="/offices/{officeId}/headlines",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="office_headlines",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.OfficeHeadlinesResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.OfficeHeadlineCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.OfficeHeadlinesResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def office_headlines_async(
        self,
        *,
        office_id: models.NWSOfficeID,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[OfficeHeadlinesAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.OfficeHeadlinesResponse:
        r"""Returns a list of news headlines for a given NWS office

        :param office_id: NWS office ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.OfficeHeadlinesRequest(
            office_id=office_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/offices/{officeId}/headlines",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="office_headlines",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.OfficeHeadlinesResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.OfficeHeadlineCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.OfficeHeadlinesResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def point(
        self,
        *,
        point: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[PointAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PointResponse:
        r"""Returns metadata about a given latitude/longitude point

        :param point: Point (latitude, longitude)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PointRequest(
            point=point,
        )

        req = self._build_request(
            method="GET",
            path="/points/{point}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="point",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.PointResponse(
                result=utils.unmarshal_json(http_res.text, models.PointGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.PointResponse(
                result=utils.unmarshal_json(http_res.text, models.PointJSONLd),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.PointResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def point_async(
        self,
        *,
        point: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[PointAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.PointResponse:
        r"""Returns metadata about a given latitude/longitude point

        :param point: Point (latitude, longitude)
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.PointRequest(
            point=point,
        )

        req = self._build_request_async(
            method="GET",
            path="/points/{point}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="point",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.PointResponse(
                result=utils.unmarshal_json(http_res.text, models.PointGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.PointResponse(
                result=utils.unmarshal_json(http_res.text, models.PointJSONLd),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.PointResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def radar_servers(
        self,
        *,
        reporting_host: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarServersAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarServersResponse:
        r"""Returns a list of radar servers

        :param reporting_host: Show records from specific reporting host
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarServersRequest(
            reporting_host=reporting_host,
        )

        req = self._build_request(
            method="GET",
            path="/radar/servers",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_servers",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarServersResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarServersResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def radar_servers_async(
        self,
        *,
        reporting_host: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarServersAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarServersResponse:
        r"""Returns a list of radar servers

        :param reporting_host: Show records from specific reporting host
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarServersRequest(
            reporting_host=reporting_host,
        )

        req = self._build_request_async(
            method="GET",
            path="/radar/servers",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_servers",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarServersResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarServersResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def radar_server(
        self,
        *,
        id: str,
        reporting_host: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarServerAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarServerResponse:
        r"""Returns metadata about a given radar server

        :param id: Server ID
        :param reporting_host: Show records from specific reporting host
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarServerRequest(
            id=id,
            reporting_host=reporting_host,
        )

        req = self._build_request(
            method="GET",
            path="/radar/servers/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_server",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarServerResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarServerResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def radar_server_async(
        self,
        *,
        id: str,
        reporting_host: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarServerAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarServerResponse:
        r"""Returns metadata about a given radar server

        :param id: Server ID
        :param reporting_host: Show records from specific reporting host
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarServerRequest(
            id=id,
            reporting_host=reporting_host,
        )

        req = self._build_request_async(
            method="GET",
            path="/radar/servers/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_server",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarServerResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarServerResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def radar_stations(
        self,
        *,
        station_type: Optional[List[str]] = None,
        reporting_host: Optional[str] = None,
        host: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarStationsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarStationsResponse:
        r"""Returns a list of radar stations

        :param station_type: Limit results to a specific station type or types
        :param reporting_host: Show RDA and latency info from specific reporting host
        :param host: Show latency info from specific LDM host
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarStationsRequest(
            station_type=station_type,
            reporting_host=reporting_host,
            host=host,
        )

        req = self._build_request(
            method="GET",
            path="/radar/stations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_stations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.RadarStationsResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarStationsResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarStationsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def radar_stations_async(
        self,
        *,
        station_type: Optional[List[str]] = None,
        reporting_host: Optional[str] = None,
        host: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarStationsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarStationsResponse:
        r"""Returns a list of radar stations

        :param station_type: Limit results to a specific station type or types
        :param reporting_host: Show RDA and latency info from specific reporting host
        :param host: Show latency info from specific LDM host
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarStationsRequest(
            station_type=station_type,
            reporting_host=reporting_host,
            host=host,
        )

        req = self._build_request_async(
            method="GET",
            path="/radar/stations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_stations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.RadarStationsResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarStationsResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarStationsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def radar_station(
        self,
        *,
        station_id: str,
        reporting_host: Optional[str] = None,
        host: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarStationAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarStationResponse:
        r"""Returns metadata about a given radar station

        :param station_id: Radar station ID
        :param reporting_host: Show RDA and latency info from specific reporting host
        :param host: Show latency info from specific LDM host
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarStationRequest(
            station_id=station_id,
            reporting_host=reporting_host,
            host=host,
        )

        req = self._build_request(
            method="GET",
            path="/radar/stations/{stationId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_station",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.RadarStationResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarStationResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarStationResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def radar_station_async(
        self,
        *,
        station_id: str,
        reporting_host: Optional[str] = None,
        host: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarStationAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarStationResponse:
        r"""Returns metadata about a given radar station

        :param station_id: Radar station ID
        :param reporting_host: Show RDA and latency info from specific reporting host
        :param host: Show latency info from specific LDM host
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarStationRequest(
            station_id=station_id,
            reporting_host=reporting_host,
            host=host,
        )

        req = self._build_request_async(
            method="GET",
            path="/radar/stations/{stationId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_station",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.RadarStationResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarStationResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarStationResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def radar_station_alarms(
        self,
        *,
        station_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarStationAlarmsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarStationAlarmsResponse:
        r"""Returns metadata about a given radar station alarms

        :param station_id: Radar station ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarStationAlarmsRequest(
            station_id=station_id,
        )

        req = self._build_request(
            method="GET",
            path="/radar/stations/{stationId}/alarms",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_station_alarms",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarStationAlarmsResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarStationAlarmsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def radar_station_alarms_async(
        self,
        *,
        station_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarStationAlarmsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarStationAlarmsResponse:
        r"""Returns metadata about a given radar station alarms

        :param station_id: Radar station ID
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarStationAlarmsRequest(
            station_id=station_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/radar/stations/{stationId}/alarms",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_station_alarms",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarStationAlarmsResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarStationAlarmsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def radar_queue(
        self,
        *,
        host: str,
        limit: Optional[int] = None,
        arrived: Optional[str] = None,
        created: Optional[str] = None,
        published: Optional[str] = None,
        station: Optional[str] = None,
        type_: Optional[str] = None,
        feed: Optional[str] = None,
        resolution: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarQueueAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarQueueResponse:
        r"""Returns metadata about a given radar queue

        :param host: LDM host
        :param limit: Record limit
        :param arrived: Range for arrival time
        :param created: Range for creation time
        :param published: Range for publish time
        :param station: Station identifier
        :param type: Record type
        :param feed: Originating product feed
        :param resolution: Resolution version
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarQueueRequest(
            host=host,
            limit=limit,
            arrived=arrived,
            created=created,
            published=published,
            station=station,
            type=type_,
            feed=feed,
            resolution=resolution,
        )

        req = self._build_request(
            method="GET",
            path="/radar/queues/{host}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_queue",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarQueueResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarQueueResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def radar_queue_async(
        self,
        *,
        host: str,
        limit: Optional[int] = None,
        arrived: Optional[str] = None,
        created: Optional[str] = None,
        published: Optional[str] = None,
        station: Optional[str] = None,
        type_: Optional[str] = None,
        feed: Optional[str] = None,
        resolution: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarQueueAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarQueueResponse:
        r"""Returns metadata about a given radar queue

        :param host: LDM host
        :param limit: Record limit
        :param arrived: Range for arrival time
        :param created: Range for creation time
        :param published: Range for publish time
        :param station: Station identifier
        :param type: Record type
        :param feed: Originating product feed
        :param resolution: Resolution version
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarQueueRequest(
            host=host,
            limit=limit,
            arrived=arrived,
            created=created,
            published=published,
            station=station,
            type=type_,
            feed=feed,
            resolution=resolution,
        )

        req = self._build_request_async(
            method="GET",
            path="/radar/queues/{host}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_queue",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarQueueResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarQueueResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def radar_profiler(
        self,
        *,
        station_id: str,
        time: Optional[str] = None,
        interval: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarProfilerAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarProfilerResponse:
        r"""Returns metadata about a given radar wind profiler

        :param station_id: Profiler station ID
        :param time: Time interval
        :param interval: Averaging interval
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarProfilerRequest(
            station_id=station_id,
            time=time,
            interval=interval,
        )

        req = self._build_request(
            method="GET",
            path="/radar/profilers/{stationId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_profiler",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarProfilerResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarProfilerResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def radar_profiler_async(
        self,
        *,
        station_id: str,
        time: Optional[str] = None,
        interval: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[RadarProfilerAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.RadarProfilerResponse:
        r"""Returns metadata about a given radar wind profiler

        :param station_id: Profiler station ID
        :param time: Time interval
        :param interval: Averaging interval
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.RadarProfilerRequest(
            station_id=station_id,
            time=time,
            interval=interval,
        )

        req = self._build_request_async(
            method="GET",
            path="/radar/profilers/{stationId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="radar_profiler",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.RadarProfilerResponse(
                result=utils.unmarshal_json(http_res.text, Any),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.RadarProfilerResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def products_query(
        self,
        *,
        location: Optional[List[str]] = None,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        office: Optional[List[str]] = None,
        wmoid: Optional[List[str]] = None,
        type_: Optional[List[str]] = None,
        limit: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductsQueryAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductsQueryResponse:
        r"""Returns a list of text products

        :param location: Location id
        :param start: Start time
        :param end: End time
        :param office: Issuing office
        :param wmoid: WMO id code
        :param type: Product code
        :param limit: Limit
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ProductsQueryRequest(
            location=location,
            start=start,
            end=end,
            office=office,
            wmoid=wmoid,
            type=type_,
            limit=limit,
        )

        req = self._build_request(
            method="GET",
            path="/products",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="products_query",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductsQueryResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductsQueryResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def products_query_async(
        self,
        *,
        location: Optional[List[str]] = None,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        office: Optional[List[str]] = None,
        wmoid: Optional[List[str]] = None,
        type_: Optional[List[str]] = None,
        limit: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductsQueryAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductsQueryResponse:
        r"""Returns a list of text products

        :param location: Location id
        :param start: Start time
        :param end: End time
        :param office: Issuing office
        :param wmoid: WMO id code
        :param type: Product code
        :param limit: Limit
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ProductsQueryRequest(
            location=location,
            start=start,
            end=end,
            office=office,
            wmoid=wmoid,
            type=type_,
            limit=limit,
        )

        req = self._build_request_async(
            method="GET",
            path="/products",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="products_query",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductsQueryResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductsQueryResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def product_locations(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductLocationsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductLocationsResponse:
        r"""Returns a list of valid text product issuance locations

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="GET",
            path="/products/locations",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="product_locations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductLocationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductLocationCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductLocationsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def product_locations_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductLocationsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductLocationsResponse:
        r"""Returns a list of valid text product issuance locations

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="GET",
            path="/products/locations",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="product_locations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductLocationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductLocationCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductLocationsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def product_types(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductTypesAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductTypesResponse:
        r"""Returns a list of valid text product types and codes

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request(
            method="GET",
            path="/products/types",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="product_types",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductTypesResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductTypeCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductTypesResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def product_types_async(
        self,
        *,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductTypesAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductTypesResponse:
        r"""Returns a list of valid text product types and codes

        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        req = self._build_request_async(
            method="GET",
            path="/products/types",
            base_url=base_url,
            url_variables=url_variables,
            request=None,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="product_types",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductTypesResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductTypeCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductTypesResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def product(
        self,
        *,
        product_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductResponse:
        r"""Returns a specific text product

        :param product_id: .
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ProductRequest(
            product_id=product_id,
        )

        req = self._build_request(
            method="GET",
            path="/products/{productId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="product",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductResponse(
                result=utils.unmarshal_json(http_res.text, models.TextProduct),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def product_async(
        self,
        *,
        product_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductResponse:
        r"""Returns a specific text product

        :param product_id: .
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ProductRequest(
            product_id=product_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/products/{productId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="product",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductResponse(
                result=utils.unmarshal_json(http_res.text, models.TextProduct),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def products_type(
        self,
        *,
        type_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductsTypeAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductsTypeResponse:
        r"""Returns a list of text products of a given type

        :param type_id: .
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ProductsTypeRequest(
            type_id=type_id,
        )

        req = self._build_request(
            method="GET",
            path="/products/types/{typeId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="products_type",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductsTypeResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductsTypeResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def products_type_async(
        self,
        *,
        type_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductsTypeAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductsTypeResponse:
        r"""Returns a list of text products of a given type

        :param type_id: .
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ProductsTypeRequest(
            type_id=type_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/products/types/{typeId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="products_type",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductsTypeResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductsTypeResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def products_type_locations(
        self,
        *,
        type_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductsTypeLocationsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductsTypeLocationsResponse:
        r"""Returns a list of valid text product issuance locations for a given product type

        :param type_id: .
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ProductsTypeLocationsRequest(
            type_id=type_id,
        )

        req = self._build_request(
            method="GET",
            path="/products/types/{typeId}/locations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="products_type_locations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductsTypeLocationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductLocationCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductsTypeLocationsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def products_type_locations_async(
        self,
        *,
        type_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductsTypeLocationsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductsTypeLocationsResponse:
        r"""Returns a list of valid text product issuance locations for a given product type

        :param type_id: .
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ProductsTypeLocationsRequest(
            type_id=type_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/products/types/{typeId}/locations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="products_type_locations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductsTypeLocationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductLocationCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductsTypeLocationsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def location_products(
        self,
        *,
        location_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[LocationProductsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.LocationProductsResponse:
        r"""Returns a list of valid text product types for a given issuance location

        :param location_id: .
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.LocationProductsRequest(
            location_id=location_id,
        )

        req = self._build_request(
            method="GET",
            path="/products/locations/{locationId}/types",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="location_products",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.LocationProductsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductTypeCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.LocationProductsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def location_products_async(
        self,
        *,
        location_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[LocationProductsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.LocationProductsResponse:
        r"""Returns a list of valid text product types for a given issuance location

        :param location_id: .
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.LocationProductsRequest(
            location_id=location_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/products/locations/{locationId}/types",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="location_products",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.LocationProductsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductTypeCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.LocationProductsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def products_type_location(
        self,
        *,
        type_id: str,
        location_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductsTypeLocationAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductsTypeLocationResponse:
        r"""Returns a list of text products of a given type for a given issuance location

        :param type_id: .
        :param location_id: .
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ProductsTypeLocationRequest(
            type_id=type_id,
            location_id=location_id,
        )

        req = self._build_request(
            method="GET",
            path="/products/types/{typeId}/locations/{locationId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="products_type_location",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductsTypeLocationResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductsTypeLocationResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def products_type_location_async(
        self,
        *,
        type_id: str,
        location_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ProductsTypeLocationAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ProductsTypeLocationResponse:
        r"""Returns a list of text products of a given type for a given issuance location

        :param type_id: .
        :param location_id: .
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ProductsTypeLocationRequest(
            type_id=type_id,
            location_id=location_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/products/types/{typeId}/locations/{locationId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/ld+json;q=1, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="products_type_location",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ProductsTypeLocationResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.TextProductCollection
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ProductsTypeLocationResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def zone_list(
        self,
        *,
        id: Optional[List[str]] = None,
        area: Optional[List[models.AreaCode]] = None,
        region: Optional[
            Union[List[models.RegionCode], List[models.RegionCodeTypedDict]]
        ] = None,
        type_: Optional[List[models.NWSZoneType]] = None,
        point: Optional[str] = None,
        include_geometry: Optional[bool] = None,
        limit: Optional[int] = None,
        effective: Optional[datetime] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ZoneListAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ZoneListResponse:
        r"""Returns a list of zones

        :param id: Zone ID (forecast or county)
        :param area: State/marine area code
        :param region: Region code
        :param type: Zone type
        :param point: Point (latitude,longitude)
        :param include_geometry: Include geometry in results (true/false)
        :param limit: Limit
        :param effective: Effective date/time
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ZoneListRequest(
            id=id,
            area=area,
            region=region,
            type=type_,
            point=point,
            include_geometry=include_geometry,
            limit=limit,
            effective=effective,
        )

        req = self._build_request(
            method="GET",
            path="/zones",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="zone_list",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ZoneListResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ZoneCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ZoneListResponse(
                result=utils.unmarshal_json(http_res.text, models.ZoneCollectionJSONLd),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ZoneListResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def zone_list_async(
        self,
        *,
        id: Optional[List[str]] = None,
        area: Optional[List[models.AreaCode]] = None,
        region: Optional[
            Union[List[models.RegionCode], List[models.RegionCodeTypedDict]]
        ] = None,
        type_: Optional[List[models.NWSZoneType]] = None,
        point: Optional[str] = None,
        include_geometry: Optional[bool] = None,
        limit: Optional[int] = None,
        effective: Optional[datetime] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ZoneListAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ZoneListResponse:
        r"""Returns a list of zones

        :param id: Zone ID (forecast or county)
        :param area: State/marine area code
        :param region: Region code
        :param type: Zone type
        :param point: Point (latitude,longitude)
        :param include_geometry: Include geometry in results (true/false)
        :param limit: Limit
        :param effective: Effective date/time
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ZoneListRequest(
            id=id,
            area=area,
            region=region,
            type=type_,
            point=point,
            include_geometry=include_geometry,
            limit=limit,
            effective=effective,
        )

        req = self._build_request_async(
            method="GET",
            path="/zones",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="zone_list",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ZoneListResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ZoneCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ZoneListResponse(
                result=utils.unmarshal_json(http_res.text, models.ZoneCollectionJSONLd),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ZoneListResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def zone_list_type(
        self,
        *,
        type_path_parameter: models.NWSZoneType,
        id: Optional[List[str]] = None,
        area: Optional[List[models.AreaCode]] = None,
        region: Optional[
            Union[List[models.RegionCode], List[models.RegionCodeTypedDict]]
        ] = None,
        type_query_parameter: Optional[List[models.NWSZoneType]] = None,
        point: Optional[str] = None,
        include_geometry: Optional[bool] = None,
        limit: Optional[int] = None,
        effective: Optional[datetime] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ZoneListTypeAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ZoneListTypeResponse:
        r"""Returns a list of zones of a given type

        :param type_path_parameter: Zone type
        :param id: Zone ID (forecast or county)
        :param area: State/marine area code
        :param region: Region code
        :param type_query_parameter: Zone type
        :param point: Point (latitude,longitude)
        :param include_geometry: Include geometry in results (true/false)
        :param limit: Limit
        :param effective: Effective date/time
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ZoneListTypeRequest(
            type_path_parameter=type_path_parameter,
            id=id,
            area=area,
            region=region,
            type_query_parameter=type_query_parameter,
            point=point,
            include_geometry=include_geometry,
            limit=limit,
            effective=effective,
        )

        req = self._build_request(
            method="GET",
            path="/zones/{type}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="zone_list_type",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ZoneListTypeResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ZoneCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ZoneListTypeResponse(
                result=utils.unmarshal_json(http_res.text, models.ZoneCollectionJSONLd),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ZoneListTypeResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def zone_list_type_async(
        self,
        *,
        type_path_parameter: models.NWSZoneType,
        id: Optional[List[str]] = None,
        area: Optional[List[models.AreaCode]] = None,
        region: Optional[
            Union[List[models.RegionCode], List[models.RegionCodeTypedDict]]
        ] = None,
        type_query_parameter: Optional[List[models.NWSZoneType]] = None,
        point: Optional[str] = None,
        include_geometry: Optional[bool] = None,
        limit: Optional[int] = None,
        effective: Optional[datetime] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ZoneListTypeAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ZoneListTypeResponse:
        r"""Returns a list of zones of a given type

        :param type_path_parameter: Zone type
        :param id: Zone ID (forecast or county)
        :param area: State/marine area code
        :param region: Region code
        :param type_query_parameter: Zone type
        :param point: Point (latitude,longitude)
        :param include_geometry: Include geometry in results (true/false)
        :param limit: Limit
        :param effective: Effective date/time
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ZoneListTypeRequest(
            type_path_parameter=type_path_parameter,
            id=id,
            area=area,
            region=region,
            type_query_parameter=type_query_parameter,
            point=point,
            include_geometry=include_geometry,
            limit=limit,
            effective=effective,
        )

        req = self._build_request_async(
            method="GET",
            path="/zones/{type}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="zone_list_type",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ZoneListTypeResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ZoneCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ZoneListTypeResponse(
                result=utils.unmarshal_json(http_res.text, models.ZoneCollectionJSONLd),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ZoneListTypeResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def zone(
        self,
        *,
        type_: models.NWSZoneType,
        zone_id: str,
        effective: Optional[datetime] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ZoneAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ZoneResponse:
        r"""Returns metadata about a given zone

        :param type: Zone type
        :param zone_id: NWS public zone/county identifier
        :param effective: Effective date/time
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ZoneRequest(
            type=type_,
            zone_id=zone_id,
            effective=effective,
        )

        req = self._build_request(
            method="GET",
            path="/zones/{type}/{zoneId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="zone",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ZoneResponse(
                result=utils.unmarshal_json(http_res.text, models.ZoneGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ZoneResponse(
                result=utils.unmarshal_json(http_res.text, models.Zone),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ZoneResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def zone_async(
        self,
        *,
        type_: models.NWSZoneType,
        zone_id: str,
        effective: Optional[datetime] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ZoneAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ZoneResponse:
        r"""Returns metadata about a given zone

        :param type: Zone type
        :param zone_id: NWS public zone/county identifier
        :param effective: Effective date/time
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ZoneRequest(
            type=type_,
            zone_id=zone_id,
            effective=effective,
        )

        req = self._build_request_async(
            method="GET",
            path="/zones/{type}/{zoneId}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="zone",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ZoneResponse(
                result=utils.unmarshal_json(http_res.text, models.ZoneGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ZoneResponse(
                result=utils.unmarshal_json(http_res.text, models.Zone),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ZoneResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def zone_forecast(
        self,
        *,
        type_: str,
        zone_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ZoneForecastAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ZoneForecastResponse:
        r"""Returns the current zone forecast for a given zone

        :param type: Zone type
        :param zone_id: NWS public zone/county identifier
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ZoneForecastRequest(
            type=type_,
            zone_id=zone_id,
        )

        req = self._build_request(
            method="GET",
            path="/zones/{type}/{zoneId}/forecast",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="zone_forecast",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ZoneForecastResponse(
                result=utils.unmarshal_json(http_res.text, models.ZoneForecastGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ZoneForecastResponse(
                result=utils.unmarshal_json(http_res.text, models.ZoneForecast),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ZoneForecastResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def zone_forecast_async(
        self,
        *,
        type_: str,
        zone_id: str,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ZoneForecastAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ZoneForecastResponse:
        r"""Returns the current zone forecast for a given zone

        :param type: Zone type
        :param zone_id: NWS public zone/county identifier
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ZoneForecastRequest(
            type=type_,
            zone_id=zone_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/zones/{type}/{zoneId}/forecast",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="zone_forecast",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ZoneForecastResponse(
                result=utils.unmarshal_json(http_res.text, models.ZoneForecastGeoJSON),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ZoneForecastResponse(
                result=utils.unmarshal_json(http_res.text, models.ZoneForecast),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ZoneForecastResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def zone_obs(
        self,
        *,
        zone_id: str,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        limit: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ZoneObsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ZoneObsResponse:
        r"""Returns a list of observations for a given zone

        :param zone_id: NWS public zone/county identifier
        :param start: Start date/time
        :param end: End date/time
        :param limit: Limit
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ZoneObsRequest(
            zone_id=zone_id,
            start=start,
            end=end,
            limit=limit,
        )

        req = self._build_request(
            method="GET",
            path="/zones/forecast/{zoneId}/observations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="zone_obs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ZoneObsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ZoneObsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ZoneObsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def zone_obs_async(
        self,
        *,
        zone_id: str,
        start: Optional[datetime] = None,
        end: Optional[datetime] = None,
        limit: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ZoneObsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ZoneObsResponse:
        r"""Returns a list of observations for a given zone

        :param zone_id: NWS public zone/county identifier
        :param start: Start date/time
        :param end: End date/time
        :param limit: Limit
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ZoneObsRequest(
            zone_id=zone_id,
            start=start,
            end=end,
            limit=limit,
        )

        req = self._build_request_async(
            method="GET",
            path="/zones/forecast/{zoneId}/observations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="zone_obs",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ZoneObsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ZoneObsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ZoneObsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def zone_stations(
        self,
        *,
        zone_id: str,
        limit: Optional[int] = 500,
        cursor: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ZoneStationsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ZoneStationsResponse:
        r"""Returns a list of observation stations for a given zone

        :param zone_id: NWS public zone/county identifier
        :param limit: Limit
        :param cursor: Pagination cursor
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ZoneStationsRequest(
            zone_id=zone_id,
            limit=limit,
            cursor=cursor,
        )

        req = self._build_request(
            method="GET",
            path="/zones/forecast/{zoneId}/stations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="zone_stations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ZoneStationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ZoneStationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ZoneStationsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def zone_stations_async(
        self,
        *,
        zone_id: str,
        limit: Optional[int] = 500,
        cursor: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        accept_header_override: Optional[ZoneStationsAcceptEnum] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.ZoneStationsResponse:
        r"""Returns a list of observation stations for a given zone

        :param zone_id: NWS public zone/county identifier
        :param limit: Limit
        :param cursor: Pagination cursor
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param accept_header_override: Override the default accept header for this method
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)

        request = models.ZoneStationsRequest(
            zone_id=zone_id,
            limit=limit,
            cursor=cursor,
        )

        req = self._build_request_async(
            method="GET",
            path="/zones/forecast/{zoneId}/stations",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value=accept_header_override.value
            if accept_header_override is not None
            else "application/geo+json;q=1, application/ld+json;q=0.7, application/problem+json;q=0",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                base_url=base_url or "",
                operation_id="zone_stations",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security, models.Security
                ),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        if utils.match_response(http_res, "200", "application/geo+json"):
            return models.ZoneStationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationCollectionGeoJSON
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "200", "application/ld+json"):
            return models.ZoneStationsResponse(
                result=utils.unmarshal_json(
                    http_res.text, models.ObservationStationCollectionJSONLd
                ),
                headers=utils.get_response_headers(http_res.headers),
            )
        if utils.match_response(http_res, "4XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )
        if utils.match_response(http_res, "default", "application/problem+json"):
            return models.ZoneStationsResponse(
                result=utils.unmarshal_json(http_res.text, models.ProblemDetail),
                headers=utils.get_response_headers(http_res.headers),
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.APIError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
