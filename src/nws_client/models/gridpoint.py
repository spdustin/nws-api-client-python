"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .gridpointquantitativevaluelayer import GridpointQuantitativeValueLayer
from .jsonldcontext_union import JSONLdContextUnion, JSONLdContextUnionTypedDict
from .quantitativevalue import QuantitativeValue, QuantitativeValueTypedDict
from datetime import datetime
from enum import Enum
from nws_client.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
import pydantic
from pydantic import ConfigDict, model_serializer
from typing import Dict, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class GridpointAtType(str, Enum):
    WX_GRIDPOINT = "wx:Gridpoint"


class Coverage(str, Enum):
    AREAS = "areas"
    BRIEF = "brief"
    CHANCE = "chance"
    DEFINITE = "definite"
    FEW = "few"
    FREQUENT = "frequent"
    INTERMITTENT = "intermittent"
    ISOLATED = "isolated"
    LIKELY = "likely"
    NUMEROUS = "numerous"
    OCCASIONAL = "occasional"
    PATCHY = "patchy"
    PERIODS = "periods"
    SCATTERED = "scattered"
    SLIGHT_CHANCE = "slight_chance"
    WIDESPREAD = "widespread"


class ValueWeather(str, Enum):
    BLOWING_DUST = "blowing_dust"
    BLOWING_SAND = "blowing_sand"
    BLOWING_SNOW = "blowing_snow"
    DRIZZLE = "drizzle"
    FOG = "fog"
    FREEZING_FOG = "freezing_fog"
    FREEZING_DRIZZLE = "freezing_drizzle"
    FREEZING_RAIN = "freezing_rain"
    FREEZING_SPRAY = "freezing_spray"
    FROST = "frost"
    HAIL = "hail"
    HAZE = "haze"
    ICE_CRYSTALS = "ice_crystals"
    ICE_FOG = "ice_fog"
    RAIN = "rain"
    RAIN_SHOWERS = "rain_showers"
    SLEET = "sleet"
    SMOKE = "smoke"
    SNOW = "snow"
    SNOW_SHOWERS = "snow_showers"
    THUNDERSTORMS = "thunderstorms"
    VOLCANIC_ASH = "volcanic_ash"
    WATER_SPOUTS = "water_spouts"


class GridpointIntensity(str, Enum):
    VERY_LIGHT = "very_light"
    LIGHT = "light"
    MODERATE = "moderate"
    HEAVY = "heavy"


class Attribute(str, Enum):
    DAMAGING_WIND = "damaging_wind"
    DRY_THUNDERSTORMS = "dry_thunderstorms"
    FLOODING = "flooding"
    GUSTY_WIND = "gusty_wind"
    HEAVY_RAIN = "heavy_rain"
    LARGE_HAIL = "large_hail"
    SMALL_HAIL = "small_hail"
    TORNADOES = "tornadoes"


class WeatherValue1TypedDict(TypedDict):
    r"""A value object representing expected weather phenomena."""

    coverage: Nullable[Coverage]
    weather: Nullable[ValueWeather]
    intensity: Nullable[GridpointIntensity]
    visibility: QuantitativeValueTypedDict
    r"""A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue

    """
    attributes: List[Attribute]


class WeatherValue1(BaseModel):
    r"""A value object representing expected weather phenomena."""

    coverage: Nullable[Coverage]

    weather: Nullable[ValueWeather]

    intensity: Nullable[GridpointIntensity]

    visibility: QuantitativeValue
    r"""A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue

    """

    attributes: List[Attribute]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["coverage", "weather", "intensity"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class WeatherValue2TypedDict(TypedDict):
    valid_time: str
    r"""A time interval in ISO 8601 format. This can be one of:

    1. Start and end time
    2. Start time and duration
    3. Duration and end time
    The string \"NOW\" can also be used in place of a start/end time.

    """
    value: List[WeatherValue1TypedDict]


class WeatherValue2(BaseModel):
    valid_time: Annotated[str, pydantic.Field(alias="validTime")]
    r"""A time interval in ISO 8601 format. This can be one of:

    1. Start and end time
    2. Start time and duration
    3. Duration and end time
    The string \"NOW\" can also be used in place of a start/end time.

    """

    value: List[WeatherValue1]


class GridpointWeatherTypedDict(TypedDict):
    values: List[WeatherValue2TypedDict]


class GridpointWeather(BaseModel):
    values: List[WeatherValue2]


class HazardsValue1TypedDict(TypedDict):
    r"""A value object representing an expected hazard."""

    phenomenon: str
    r"""Hazard code. This value will correspond to a P-VTEC phenomenon code as defined in NWS Directive 10-1703.

    """
    significance: str
    r"""Significance code. This value will correspond to a P-VTEC significance code as defined in NWS Directive 10-1703.
    This will most frequently be \"A\" for a watch or \"Y\" for an advisory.

    """
    event_number: Nullable[int]
    r"""Event number. If this hazard refers to a national or regional center product (such as a Storm Prediction Center convective watch), this value will be the sequence number of that product.

    """


class HazardsValue1(BaseModel):
    r"""A value object representing an expected hazard."""

    phenomenon: str
    r"""Hazard code. This value will correspond to a P-VTEC phenomenon code as defined in NWS Directive 10-1703.

    """

    significance: str
    r"""Significance code. This value will correspond to a P-VTEC significance code as defined in NWS Directive 10-1703.
    This will most frequently be \"A\" for a watch or \"Y\" for an advisory.

    """

    event_number: Nullable[int]
    r"""Event number. If this hazard refers to a national or regional center product (such as a Storm Prediction Center convective watch), this value will be the sequence number of that product.

    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["event_number"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class HazardsValue2TypedDict(TypedDict):
    valid_time: str
    r"""A time interval in ISO 8601 format. This can be one of:

    1. Start and end time
    2. Start time and duration
    3. Duration and end time
    The string \"NOW\" can also be used in place of a start/end time.

    """
    value: List[HazardsValue1TypedDict]


class HazardsValue2(BaseModel):
    valid_time: Annotated[str, pydantic.Field(alias="validTime")]
    r"""A time interval in ISO 8601 format. This can be one of:

    1. Start and end time
    2. Start time and duration
    3. Duration and end time
    The string \"NOW\" can also be used in place of a start/end time.

    """

    value: List[HazardsValue1]


class HazardsTypedDict(TypedDict):
    values: List[HazardsValue2TypedDict]


class Hazards(BaseModel):
    values: List[HazardsValue2]


class GridpointTypedDict(TypedDict):
    r"""Raw forecast data for a 2.5km grid square.
    This is a list of all potential data layers that may appear. Some layers may not be present in all areas.
    * temperature
    * dewpoint
    * maxTemperature
    * minTemperature
    * relativeHumidity
    * apparentTemperature
    * heatIndex
    * windChill
    * wetBulbGlobeTemperature
    * skyCover
    * windDirection
    * windSpeed
    * windGust
    * weather
    * hazards: Watch and advisory products in effect
    * probabilityOfPrecipitation
    * quantitativePrecipitation
    * iceAccumulation
    * snowfallAmount
    * snowLevel
    * ceilingHeight
    * visibility
    * transportWindSpeed
    * transportWindDirection
    * mixingHeight
    * hainesIndex
    * lightningActivityLevel
    * twentyFootWindSpeed
    * twentyFootWindDirection
    * waveHeight
    * wavePeriod
    * waveDirection
    * primarySwellHeight
    * primarySwellDirection
    * secondarySwellHeight
    * secondarySwellDirection
    * wavePeriod2
    * windWaveHeight
    * dispersionIndex
    * pressure: Barometric pressure
    * probabilityOfTropicalStormWinds
    * probabilityOfHurricaneWinds
    * potentialOf15mphWinds
    * potentialOf25mphWinds
    * potentialOf35mphWinds
    * potentialOf45mphWinds
    * potentialOf20mphWindGusts
    * potentialOf30mphWindGusts
    * potentialOf40mphWindGusts
    * potentialOf50mphWindGusts
    * potentialOf60mphWindGusts
    * grasslandFireDangerIndex
    * probabilityOfThunder
    * davisStabilityIndex
    * atmosphericDispersionIndex
    * lowVisibilityOccurrenceRiskIndex
    * stability
    * redFlagThreatIndex

    """

    at_context: NotRequired[JSONLdContextUnionTypedDict]
    geometry: NotRequired[Nullable[str]]
    r"""A geometry represented in Well-Known Text (WKT) format."""
    at_id: NotRequired[str]
    at_type: NotRequired[GridpointAtType]
    update_time: NotRequired[datetime]
    valid_times: NotRequired[str]
    r"""A time interval in ISO 8601 format. This can be one of:

    1. Start and end time
    2. Start time and duration
    3. Duration and end time
    The string \"NOW\" can also be used in place of a start/end time.

    """
    elevation: NotRequired[QuantitativeValueTypedDict]
    r"""A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue

    """
    forecast_office: NotRequired[str]
    grid_id: NotRequired[str]
    grid_x: NotRequired[int]
    grid_y: NotRequired[int]
    weather: NotRequired[GridpointWeatherTypedDict]
    hazards: NotRequired[HazardsTypedDict]


class Gridpoint(BaseModel):
    r"""Raw forecast data for a 2.5km grid square.
    This is a list of all potential data layers that may appear. Some layers may not be present in all areas.
    * temperature
    * dewpoint
    * maxTemperature
    * minTemperature
    * relativeHumidity
    * apparentTemperature
    * heatIndex
    * windChill
    * wetBulbGlobeTemperature
    * skyCover
    * windDirection
    * windSpeed
    * windGust
    * weather
    * hazards: Watch and advisory products in effect
    * probabilityOfPrecipitation
    * quantitativePrecipitation
    * iceAccumulation
    * snowfallAmount
    * snowLevel
    * ceilingHeight
    * visibility
    * transportWindSpeed
    * transportWindDirection
    * mixingHeight
    * hainesIndex
    * lightningActivityLevel
    * twentyFootWindSpeed
    * twentyFootWindDirection
    * waveHeight
    * wavePeriod
    * waveDirection
    * primarySwellHeight
    * primarySwellDirection
    * secondarySwellHeight
    * secondarySwellDirection
    * wavePeriod2
    * windWaveHeight
    * dispersionIndex
    * pressure: Barometric pressure
    * probabilityOfTropicalStormWinds
    * probabilityOfHurricaneWinds
    * potentialOf15mphWinds
    * potentialOf25mphWinds
    * potentialOf35mphWinds
    * potentialOf45mphWinds
    * potentialOf20mphWindGusts
    * potentialOf30mphWindGusts
    * potentialOf40mphWindGusts
    * potentialOf50mphWindGusts
    * potentialOf60mphWindGusts
    * grasslandFireDangerIndex
    * probabilityOfThunder
    * davisStabilityIndex
    * atmosphericDispersionIndex
    * lowVisibilityOccurrenceRiskIndex
    * stability
    * redFlagThreatIndex

    """

    model_config = ConfigDict(
        populate_by_name=True, arbitrary_types_allowed=True, extra="allow"
    )
    __pydantic_extra__: Dict[str, GridpointQuantitativeValueLayer] = pydantic.Field(
        init=False
    )

    at_context: Annotated[
        Optional[JSONLdContextUnion], pydantic.Field(alias="@context")
    ] = None

    geometry: OptionalNullable[str] = UNSET
    r"""A geometry represented in Well-Known Text (WKT) format."""

    at_id: Annotated[Optional[str], pydantic.Field(alias="@id")] = None

    at_type: Annotated[Optional[GridpointAtType], pydantic.Field(alias="@type")] = None

    update_time: Annotated[Optional[datetime], pydantic.Field(alias="updateTime")] = (
        None
    )

    valid_times: Annotated[Optional[str], pydantic.Field(alias="validTimes")] = None
    r"""A time interval in ISO 8601 format. This can be one of:

    1. Start and end time
    2. Start time and duration
    3. Duration and end time
    The string \"NOW\" can also be used in place of a start/end time.

    """

    elevation: Optional[QuantitativeValue] = None
    r"""A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue

    """

    forecast_office: Annotated[
        Optional[str], pydantic.Field(alias="forecastOffice")
    ] = None

    grid_id: Annotated[Optional[str], pydantic.Field(alias="gridId")] = None

    grid_x: Annotated[Optional[int], pydantic.Field(alias="gridX")] = None

    grid_y: Annotated[Optional[int], pydantic.Field(alias="gridY")] = None

    weather: Optional[GridpointWeather] = None

    hazards: Optional[Hazards] = None

    @property
    def additional_properties(self):
        return self.__pydantic_extra__

    @additional_properties.setter
    def additional_properties(self, value):
        self.__pydantic_extra__ = value  # pyright: ignore[reportIncompatibleVariableOverride]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "@context",
            "geometry",
            "@id",
            "@type",
            "updateTime",
            "validTimes",
            "elevation",
            "forecastOffice",
            "gridId",
            "gridX",
            "gridY",
            "weather",
            "hazards",
        ]
        nullable_fields = ["geometry"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        for k, v in serialized.items():
            m[k] = v

        return m
